<p style="box-sizing: border-box; margin: 0px 0px 10px; font-size: 16px; color: #333333; font-family: Raleway;">Computer science is all about providing&nbsp;<span style="box-sizing: border-box; font-weight: bold;">abstractions</span>&nbsp;and their efficient implementation. An abstraction provides a logical view of a certain service or a resource by giving a well-defined black-box model, its associated properties and hides the internal details of the black-box. For example the design and implementation of a processor is abstracted away through the Instruction Set Architecture (ISA) of the processor. Further high level programming languages like C, C++ abstracts away ISA of a processor by allowing the programmers to express their intent using language constructs like for-loops, while-loops etc. Wherever we use abstractions we have to rely on some one for efficient realization of those abstractions. In the case of ISA of a processor, we rely on the processor designer and in the case of high level programming languages we rely on a compiler.</p>
<p style="box-sizing: border-box; margin: 0px 0px 10px; font-size: 16px; color: #333333; font-family: Raleway;">In this lab, the first two experiments deal with the two primitive data abstractions, integers and floating point numbers. We look at various approaches for representing&nbsp;<span style="box-sizing: border-box; font-weight: bold;">integers</span>&nbsp;and&nbsp;<span style="box-sizing: border-box; font-weight: bold;">floating-point&nbsp;</span>numbers in binary and, their pros and cons. The next four experiments involve writing&nbsp;<span style="box-sizing: border-box; font-weight: bold;">assembly language programs</span>&nbsp;using MIPS and ARM ISA. In these experiments we learn how to map high-level language contructs to a sequence of assembly language instructions. In the last experiment of this lab we shall study how to design a processor for a subset of MIPS ISA using Single Cycle Per Instruction approach. The idea here is that we would like to understand how we can map high level language constructs to assembly programs, followed by that how to realize the assembly instructions using logic gates as building blocks.</p>
<p style="box-sizing: border-box; margin: 0px 0px 10px; font-size: 16px; color: #333333; font-family: Raleway;">Processor, Memory and I/O Devices are three major subsystems in a computer.&nbsp;<span style="box-sizing: border-box; font-weight: bold;">Cache memory</span>&nbsp;plays major role in bridging the speed mismatch between a processor and the associated main memory module. We have three experiments on cache memories to illustrate various possible cache organizations and the impact of cache organizations on program performance. We have one more experiment illustrating the concept of&nbsp;<span style="box-sizing: border-box; font-weight: bold;">Virtual Memory</span>.</p>